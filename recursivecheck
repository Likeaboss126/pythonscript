def clean_html(raw_html):
    """Converts Confluence XHTML into clean text for the AI."""
    if not raw_html:
        return ""
    soup = BeautifulSoup(raw_html, "html.parser")
    # Remove script and style elements
    for script_or_style in soup(["script", "style"]):
        script_or_style.decompose()
    return soup.get_text(separator=' ', strip=True)

def recursive_search_by_title(space, title, level=0):
    indent = "  " * level
    try:
        # FETCH
        page = confluence.get_page_by_title(space=space, title=title, expand='body.storage')
        
        # ERROR CHECK: If page is a string, it means the API returned an error message
        if isinstance(page, str):
            print(f"{indent}‚ùå API returned a string instead of data for '{title}'.")
            print(f"{indent}Response Snippet: {page[:100]}")
            return

        if not page or 'id' not in page:
            print(f"{indent}‚ö†Ô∏è Page not found or access denied: {title}")
            return

        # EXTRACT
        page_id = page['id']
        raw_content = page.get('body', {}).get('storage', {}).get('value', '')
        clean_text = clean_html(raw_content)
        
        print(f"{indent}üìÑ {title} (ID: {page_id})")
        print(f"{indent}‚ú® Clean Text Preview: {clean_text[:75]}...")

        # FIND CHILDREN
        # We use the ID to find children, but then we recurse using their titles
        children = confluence.get_page_child_by_type(page_id, type='page')
        
        for child in children:
            if isinstance(child, dict) and 'title' in child:
                time.sleep(0.5)
                recursive_search_by_title(space, child['title'], level + 1)

    except Exception as e:
        print(f"{indent}üí• Python Error: {e}")

print(f"üöÄ Verifying: {SPACE_KEY} / {START_PAGE_TITLE}")
recursive_search_by_title(SPACE_KEY, START_PAGE_TITLE)

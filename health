st.subheader("ğŸ“ˆ Weekly Trend Indicators (Avg > 2000ms)")

# Filter by selected functionalities only â€” include all APIs under them
df_func_filtered = df[df['Functionality'].isin(selected_funcs)].copy()

# Convert to week number
df_func_filtered['Week'] = pd.to_datetime(df_func_filtered['DateTime']).dt.isocalendar().week

# Identify the latest two weeks available
latest_weeks = sorted(df_func_filtered['Week'].unique())
if len(latest_weeks) >= 2:
    week1, week2 = latest_weeks[-2], latest_weeks[-1]

    # Split data
    df_w1 = df_func_filtered[df_func_filtered['Week'] == week1]
    df_w2 = df_func_filtered[df_func_filtered['Week'] == week2]

    # Aggregate average response per API per functionality
    agg_w1 = df_w1.groupby(['Functionality', 'API'])['Averagetimetaken'].mean().reset_index(name='Avg_Week1')
    agg_w2 = df_w2.groupby(['Functionality', 'API'])['Averagetimetaken'].mean().reset_index(name='Avg_Week2')

    # Merge
    merged = pd.merge(agg_w1, agg_w2, on=['Functionality', 'API'])

    # Calculate % change
    merged['Change %'] = ((merged['Avg_Week2'] - merged['Avg_Week1']) / merged['Avg_Week1']) * 100

    # âœ… Filter only APIs where latest week average > 2000 ms
    merged = merged[merged['Avg_Week2'] > 2000]

    # Optional: Keep only significant changes (e.g., > Â±2%)
    merged = merged[merged['Change %'].abs() >= 2]

    # Add trend indicators
    def trend(row):
        if row['Change %'] > 0:
            return f"ğŸ”´â¬‡ï¸ Slower by {abs(row['Change %']):.2f}%"
        else:
            return f"ğŸŸ¢â¬†ï¸ Faster by {abs(row['Change %']):.2f}%"

    merged['Trend'] = merged.apply(trend, axis=1)

    # Sort by latest week average descending (most problematic first)
    merged = merged.sort_values(by='Avg_Week2', ascending=False)

    # Display result
    st.dataframe(
        merged[['Functionality', 'API', 'Avg_Week1', 'Avg_Week2', 'Change %', 'Trend']],
        use_container_width=True
    )
else:
    st.info("Not enough weekly data for comparison.")
